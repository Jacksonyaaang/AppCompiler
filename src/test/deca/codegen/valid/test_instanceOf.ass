	TSTO #29
	BOV stack_overflow_error
	ADDSP #26
; start main program
; -------------------------------------
;        Method Table
; -------------------------------------
	LOAD #null, R0
	STORE R0, 15(GB)
	LOAD code.Object.equals, R0
	STORE R0, 16(GB)
	LEA 15(GB), R0
	STORE R0, 17(GB)
	LOAD code.Object.equals, R0
	STORE R0, 18(GB)
	LEA 17(GB), R0
	STORE R0, 19(GB)
	LOAD code.Object.equals, R0
	STORE R0, 20(GB)
	LEA 19(GB), R0
	STORE R0, 21(GB)
	LOAD code.Object.equals, R0
	STORE R0, 22(GB)
	LEA 17(GB), R0
	STORE R0, 23(GB)
	LOAD code.Object.equals, R0
	STORE R0, 24(GB)
	LEA 21(GB), R0
	STORE R0, 25(GB)
	LOAD code.Object.equals, R0
	STORE R0, 26(GB)
; -------------------------------------
;        Main program
; -------------------------------------
; Beginning of main instructions:
	LOAD #2, R2	; loading 2 into memory
	STORE R2, 1(GB)	; Initializing the variable x and loading it into memory
	LOAD #2, R2	; loading 2 into memory
	STORE R2, 2(GB)	; Initializing the variable y and loading it into memory
	LOAD #2, R2	; loading 2 into memory
	STORE R2, 3(GB)	; Initializing the variable z and loading it into memory
	LOAD #2, R2	; loading 2 into memory
	STORE R2, 4(GB)	; Initializing the variable h and loading it into memory
	LOAD #2, R2	; loading 2 into memory
	STORE R2, 5(GB)	; Initializing the variable v and loading it into memory
	LOAD #1, R2	; loading true into memory
	STORE R2, 6(GB)	; Initializing the variable b1 and loading it into memory
	LOAD #1, R2	; loading true into memory
	STORE R2, 7(GB)	; Initializing the variable b2 and loading it into memory
	LOAD #0, R2	; loading false into memory
	STORE R2, 8(GB)	; Initializing the variable b3 and loading it into memory
	LOAD #0, R2	; loading false into memory
	STORE R2, 9(GB)	; Initializing the variable b4 and loading it into memory
; --------StartNew--------[31, 10]-----
; [New][loadItemintoRegister] loading new of calss =  A into memory at register R2
	NEW #1, R2
	BOV heap_overflow_error
	LEA 17(GB), R0
	STORE R0, 0(R2)
	PUSH R2
	BSR init.A
	POP R2
; --------EndNew--------[31, 10]-----
	STORE R2, 10(GB)	; Initializing the variable a and loading it into memory
; --------StartNew--------[32, 9]-----
; [New][loadItemintoRegister] loading new of calss =  B into memory at register R2
	NEW #1, R2
	BOV heap_overflow_error
	LEA 19(GB), R0
	STORE R0, 0(R2)
	PUSH R2
	BSR init.B
	POP R2
; --------EndNew--------[32, 9]-----
	STORE R2, 11(GB)	; Initializing the variable b and loading it into memory
; --------StartNew--------[33, 10]-----
; [New][loadItemintoRegister] loading new of calss =  C into memory at register R2
	NEW #1, R2
	BOV heap_overflow_error
	LEA 21(GB), R0
	STORE R0, 0(R2)
	PUSH R2
	BSR init.C
	POP R2
; --------EndNew--------[33, 10]-----
	STORE R2, 12(GB)	; Initializing the variable c and loading it into memory
; --------StartNew--------[34, 9]-----
; [New][loadItemintoRegister] loading new of calss =  D into memory at register R2
	NEW #1, R2
	BOV heap_overflow_error
	LEA 23(GB), R0
	STORE R0, 0(R2)
	PUSH R2
	BSR init.D
	POP R2
; --------EndNew--------[34, 9]-----
	STORE R2, 13(GB)	; Initializing the variable d and loading it into memory
; --------StartNew--------[35, 10]-----
; [New][loadItemintoRegister] loading new of calss =  H into memory at register R2
	NEW #1, R2
	BOV heap_overflow_error
	LEA 25(GB), R0
	STORE R0, 0(R2)
	PUSH R2
	BSR init.H
	POP R2
; --------EndNew--------[35, 10]-----
	STORE R2, 14(GB)	; Initializing the variable p and loading it into memory
; --------------BeginInstanceof----------[36, 7]+-----
	WSTR "START instanceof"
	WNL
	LEA 17(GB), R0	; loading method table of A
	LEA 19(GB), R1	; loading method table of B
	CMP R1, R0
	BEQ instanceOf_Object1	; si les deux classes sont les mêmes , on retourne immédiatement true
	LOAD 11(GB), R2	; loading b into memory
	WSTR "BEFORE LOOP"
	WNL
loopbegin1:
	WSTR "INSIDE LOOP"
	WNL
	CMP R0, R2
	BEQ instanceOf_Object1	; loopend
	LOAD 0(R2), R2
	CMP #null, R2
	BEQ endfalse1
	BRA loopbegin1
instanceOf_Object1:
	WSTR "TRUE "
	WNL
	LOAD #1, R0
	BRA endtrue1
endfalse1:
	WSTR "FALSE "
	WNL
	LOAD #0, R0
endtrue1:
	LOAD R0, R2
	WSTR "END instanceof"
	WNL
; --------------EndInstanceof----------[36, 7]-----
; ---------Startif-----------[36, 4]
	CMP #1, R2	; Comparing expr output in the ifthenelse
	BNE else1
	WSTR "instanceof fonctionne b instanceof A"
	WNL
	BRA end_ifthenelse_1
else1:
end_ifthenelse_1:
; ---------Endif-----------
; --------------BeginInstanceof----------[50, 7]+-----
	WSTR "START instanceof"
	WNL
	LEA 19(GB), R0	; loading method table of B
	LEA 17(GB), R1	; loading method table of A
	CMP R1, R0
	BEQ instanceOf_Object2	; si les deux classes sont les mêmes , on retourne immédiatement true
	LOAD 10(GB), R2	; loading a into memory
	WSTR "BEFORE LOOP"
	WNL
loopbegin2:
	WSTR "INSIDE LOOP"
	WNL
	CMP R0, R2
	BEQ instanceOf_Object2	; loopend
	LOAD 0(R2), R2
	CMP #null, R2
	BEQ endfalse2
	BRA loopbegin2
instanceOf_Object2:
	WSTR "TRUE "
	WNL
	LOAD #1, R0
	BRA endtrue2
endfalse2:
	WSTR "FALSE "
	WNL
	LOAD #0, R0
endtrue2:
	LOAD R0, R2
	WSTR "END instanceof"
	WNL
; --------------EndInstanceof----------[50, 7]-----
; ---------Startif-----------[50, 4]
	CMP #1, R2	; Comparing expr output in the ifthenelse
	BNE else2
	WSTR "Problem with code"
	WNL
	BRA end_ifthenelse_2
else2:
	WSTR "instanceof fonctionne a not instanceof B"
	WNL
end_ifthenelse_2:
; ---------Endif-----------
; --------------BeginInstanceof----------[57, 7]+-----
	WSTR "START instanceof"
	WNL
	LEA 17(GB), R0	; loading method table of A
	LEA 25(GB), R1	; loading method table of H
	CMP R1, R0
	BEQ instanceOf_Object3	; si les deux classes sont les mêmes , on retourne immédiatement true
	LOAD 14(GB), R2	; loading p into memory
	WSTR "BEFORE LOOP"
	WNL
loopbegin3:
	WSTR "INSIDE LOOP"
	WNL
	CMP R0, R2
	BEQ instanceOf_Object3	; loopend
	LOAD 0(R2), R2
	CMP #null, R2
	BEQ endfalse3
	BRA loopbegin3
instanceOf_Object3:
	WSTR "TRUE "
	WNL
	LOAD #1, R0
	BRA endtrue3
endfalse3:
	WSTR "FALSE "
	WNL
	LOAD #0, R0
endtrue3:
	LOAD R0, R2
	WSTR "END instanceof"
	WNL
; --------------EndInstanceof----------[57, 7]-----
; ---------Startif-----------[57, 4]
	CMP #1, R2	; Comparing expr output in the ifthenelse
	BNE else3
	WSTR "instanceof fonctionne H instanceof A"
	WNL
	BRA end_ifthenelse_3
else3:
end_ifthenelse_3:
; ---------Endif-----------
; --------------BeginInstanceof----------[61, 10]+-----
	WSTR "START instanceof"
	WNL
	LEA 23(GB), R0	; loading method table of D
	LEA 21(GB), R1	; loading method table of C
	CMP R1, R0
	BEQ instanceOf_Object4	; si les deux classes sont les mêmes , on retourne immédiatement true
	LOAD 12(GB), R2	; loading c into memory
	WSTR "BEFORE LOOP"
	WNL
loopbegin4:
	WSTR "INSIDE LOOP"
	WNL
	CMP R0, R2
	BEQ instanceOf_Object4	; loopend
	LOAD 0(R2), R2
	CMP #null, R2
	BEQ endfalse4
	BRA loopbegin4
instanceOf_Object4:
	WSTR "TRUE "
	WNL
	LOAD #1, R0
	BRA endtrue4
endfalse4:
	WSTR "FALSE "
	WNL
	LOAD #0, R0
endtrue4:
	LOAD R0, R2
	WSTR "END instanceof"
	WNL
; --------------EndInstanceof----------[61, 10]-----
	CMP #0, R2	; Applying not operand
	SEQ R2	; Applying not operand
; ---------Startif-----------[61, 4]
	CMP #1, R2	; Comparing expr output in the ifthenelse
	BNE else4
	WSTR "instanceof fonctionne c is not  instanceof D"
	WNL
	BRA end_ifthenelse_4
else4:
	WSTR "problem with code"
	WNL
end_ifthenelse_4:
; ---------Endif-----------
	HALT
; -------------------------------------
;        Classes
; -------------------------------------
; ---------------------------------------------------
; ----------------- class : A -------------------
; ---------------------------------------------------
; ------------Init method for class = A--------
init.A:
	RTS
; ---------------------------------------------------
; ----------------- class : B -------------------
; ---------------------------------------------------
; ------------Init method for class = B--------
init.B:
	TSTO #3
	BOV stack_overflow_error
	LOAD -2(LB), R0	; Placing the current class = B adresse in the the stack before calling parent 
	PUSH R0	; Placing this = B into the stack
	BSR init.A	; Calling the initialisation method of parent classA
	SUBSP #1
	RTS
; ---------------------------------------------------
; ----------------- class : C -------------------
; ---------------------------------------------------
; ------------Init method for class = C--------
init.C:
	TSTO #3
	BOV stack_overflow_error
	LOAD -2(LB), R0	; Placing the current class = C adresse in the the stack before calling parent 
	PUSH R0	; Placing this = C into the stack
	BSR init.B	; Calling the initialisation method of parent classB
	SUBSP #1
	RTS
; ---------------------------------------------------
; ----------------- class : D -------------------
; ---------------------------------------------------
; ------------Init method for class = D--------
init.D:
	TSTO #3
	BOV stack_overflow_error
	LOAD -2(LB), R0	; Placing the current class = D adresse in the the stack before calling parent 
	PUSH R0	; Placing this = D into the stack
	BSR init.A	; Calling the initialisation method of parent classA
	SUBSP #1
	RTS
; ---------------------------------------------------
; ----------------- class : H -------------------
; ---------------------------------------------------
; ------------Init method for class = H--------
init.H:
	TSTO #3
	BOV stack_overflow_error
	LOAD -2(LB), R0	; Placing the current class = H adresse in the the stack before calling parent 
	PUSH R0	; Placing this = H into the stack
	BSR init.C	; Calling the initialisation method of parent classC
	SUBSP #1
	RTS
; -------------------------------------
;        Method equal
; -------------------------------------
; ------------------Start generateCodeForObjectEquals location:
code.Object.equals:
	LOAD -2(LB), R0
	CMP R1, R0
	SEQ R0	; Comparaison this et paramètre d'equals
fin.Object.equals:
	RTS
init.Object:
	RTS
; -------------------------------------
;        Liste Erreur
; -------------------------------------
heap_overflow_error:
	WSTR "Error: heap_overflow_error"
	WNL
	ERROR
stack_overflow_error:
	WSTR "Error: stack_overflow_error"
	WNL
	ERROR
; end main program
